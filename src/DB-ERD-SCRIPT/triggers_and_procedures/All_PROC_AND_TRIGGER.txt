DELIMITER //
CREATE PROCEDURE `PROC_CANCEL_THE_PROGRESSING_PO_G4`(IN inPoNoG4 INT(11))
BEGIN
	DECLARE statusNo INT;
    DECLARE poNo INT;
	-- DEFINE AN ERROR HANDLING. FIRST ROLLBACK THEN RETHROW THE ERROR TO THE REQUESTOR APPLICATION.
    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING, NOT FOUND
    BEGIN
		ROLLBACK;
        RESIGNAL;
	END;
    -- TRANSACTION
	START TRANSACTION;
    set poNo = TRIM(inPoNoG4);
    IF ISNULL(inPoNoG4) THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='Null value is not accepted.';
    ELSE
		SELECT statusNoG4 INTO statusNo FROM POsG4 JOIN StatusG4 ON POsG4.statusG4 =StatusG4.statusNoG4 WHERE poNoG4 = poNo;
		IF statusNo = 1 THEN 
			UPDATE POsG4
			SET statusG4 = 5
			WHERE poNoG4 = poNo;
		ELSEIF statusNo = 2 THEN 
			UPDATE POsG4
			SET statusG4 = 5
			WHERE poNoG4 = poNo;
		ELSEIF statusNo = 3 THEN 
			UPDATE POsG4
			SET statusG4 = 5
			WHERE poNoG4 = poNo;
		ELSEIF statusNo = 4 THEN 
			UPDATE POsG4
			SET statusG4 = 5
			WHERE poNoG4 = poNo;
            	-- posg4_AFTER_UPDATE_STATUS_REFUND trigger will do the refound money and restock qty in parts
       		ELSEIF statusNo = 5 THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT='This purchurse order has already been canceled';
        END IF;
    END IF;
    -- COMMIT THE ENTIRE CHANGE.
    COMMIT;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE `CUSTOMER_UPDATE_G4`(IN inClientCompIdG4 INT(11), IN inClientCompNameG4 VARCHAR(255), IN inClientCityG4  VARCHAR(255), IN inClientCompPasswordG4 VARCHAR(255), IN inMoneyOwedG4 decimal(19,4))
BEGIN
	-- DEFINE AN ERROR HANDLING. FIRST ROLLBACK THEN RETHROW THE ERROR TO THE REQUESTOR APPLICATION.
    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING, NOT FOUND
    BEGIN
		ROLLBACK;
        RESIGNAL;
	END;
    -- TRANSACTION
	START TRANSACTION;
    IF ISNULL(inClientCompIdG4) OR ISNULL(inClientCompNameG4) OR ISNULL(inClientCityG4) OR ISNULL(inClientCompPasswordG4) OR ISNULL(inMoneyOwedG4) THEN
		-- USER DEFINED ERROR (NULL VALUE IS NOT ACCEPTED).
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='Null value is not accepted.';
    ELSE
    -- UPDATE THE INFORMATION IN THE CLIENTG4 TABLE.
    UPDATE ClientG4 SET moneyOwedG4=inMoneyOwedG4, clientCompNameG4=inClientCompNameG4,
			clientCityG4=inClientCityG4, clientCompPasswordG4=inClientCompPasswordG4 WHERE clientCompIdG4=inClientCompIdG4;
	-- RETURN THE UPDATED INFORMATION BACK TO THE REQUESTOR.
	SELECT * FROM ClientG4 WHERE clientCompIdG4=inClientCompIdG4;
    END IF;
    -- COMMIT THE ENTIRE CHANGE.
    COMMIT;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE `PROC_PART_PRICE_ADJUSTMENT_G4`(IN inPartNoG4 INT(11), IN inCurrentPriceG4 DECIMAL(19,4))
BEGIN
	-- DEFINE AN ERROR HANDLING. FIRST ROLLBACK THEN RETHROW THE ERROR TO THE REQUESTOR APPLICATION.
    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING, NOT FOUND
    BEGIN
		ROLLBACK;
        RESIGNAL;
	END;	
    -- TRANSACTION
	START TRANSACTION;
    IF ISNULL(inPartNoG4) OR ISNULL(inCurrentPriceG4) THEN
		-- USER DEFINED ERROR (NULL VALUE IS NOT ACCEPTED).
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='Null value is not accepted.';
    ELSEIF SIGN(inCurrentPriceG4) < 0 THEN -- FOR NOW, PRICE SHOULD BE A POSITIVE NUMBER.
		-- USER DEFINED ERROR (PRICE CANNOT BE LESS THAN ZERO).
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='Price cannot be less than zero.';
    ELSE
    -- UPDATE THE INFORMATION IN THE PARTSG4 TABLE.
    UPDATE PartsG4 SET currentPriceG4=inCurrentPriceG4 WHERE partNoG4=inPartNoG4;
	-- RETURN THE UPDATED INFORMATION BACK TO THE REQUESTOR.
	SELECT * FROM PartsG4 WHERE partNoG4=inPartNoG4;
    END IF;
    -- COMMIT THE ENTIRE CHANGE.
    COMMIT;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE `PROC_PART_UPDATE_G4`(IN inPartNoG4 INT(11), IN inPartNameG4 VARCHAR(255), IN inPartDescriptionG4 VARCHAR(255), IN inCurrentPriceG4 DECIMAL(19,4), IN inQtyG4 INT(11), inMinQtyG4 int(11))
BEGIN
	-- DECLARE THE VARIABLES FOR THE QUANTITY CALCULATION.
	DECLARE CURR_QTY INT;
	DECLARE MIN_QTY INT;
	-- DEFINE AN ERROR HANDLING. FIRST ROLLBACK THEN RETHROW THE ERROR TO THE REQUESTOR APPLICATION.
    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING, NOT FOUND
    BEGIN
		ROLLBACK;
        RESIGNAL;
	END;
    -- TRANSACTION
	START TRANSACTION;
    IF ISNULL(inPartNameG4) OR ISNULL(inPartDescriptionG4) OR ISNULL(inCurrentPriceG4) OR ISNULL(inQtyG4) OR ISNULL(inMinQtyG4) THEN
		-- USER DEFINED ERROR (NULL VALUE IS NOT ACCEPTED).
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='Null value is not accepted.';
    ELSEIF (SIGN(inQtyG4) < 0) OR (SIGN(inMinQtyG4) < 0) THEN
		-- USER DEFINED ERROR (QTY OR MINQTY CANNOT BE LESS THAN ZERO).
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='QTY and minQTY cannot be less than zero.';
    ELSE
    -- UPDATE THE INFORMATION IN THE PARTSG4 TABLE.
    UPDATE PartsG4 SET partNameG4=inPartNameG4, partDescriptionG4=inPartDescriptionG4,
			currentPriceG4=inCurrentPriceG4, qtyG4=inQtyG4, minQtyG4=inMinQtyG4 WHERE partNoG4=inPartNoG4;

	-- RECALCULATE AND UPDATE THE REORDER FLAG.
	SELECT qtyG4 INTO CURR_QTY FROM PartsG4 WHERE partNoG4 = inPartNoG4;
	SELECT minQtyG4 INTO MIN_QTY FROM PartsG4 WHERE partNoG4 = inPartNoG4;
   	IF (CURR_QTY < MIN_QTY) THEN
		-- MARK THE PART TO BE REORDERED SINCE THE CURRENT QUANTITY IS BELOW THE MANDATORY THRESHOLD.
		UPDATE PartsG4 SET reorderG4 = 1 WHERE partNoG4 = inPartNoG4;
	ELSE
		-- MARK THE PART NOT TO BE REORDERED.
		UPDATE PartsG4 SET reorderG4 = 0 WHERE partNoG4 = inPartNoG4;
	END IF;
	-- RETURN THE UPDATED INFORMATION BACK TO THE REQUESTOR.
	SELECT * FROM PartsG4 WHERE partNoG4=inPartNoG4;
    END IF;
    -- COMMIT THE ENTIRE CHANGE.
    COMMIT;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE `PROC_PARTS_REPLENISH_G4`(IN inPartNoG4 INT(11), IN inQtyG4 INT(11))
BEGIN
	-- DECLARE THE VARIABLES FOR THE QUANTITY CALCULATION.
	DECLARE CURR_QTY INT;
	DECLARE MIN_QTY INT;
	-- DEFINE AN ERROR HANDLING. FIRST ROLLBACK THEN RETHROW THE ERROR TO THE REQUESTOR APPLICATION.
    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING, NOT FOUND
    BEGIN
		ROLLBACK;
        RESIGNAL;
	END;	
    -- TRANSACTION
	START TRANSACTION;
    IF ISNULL(inPartNoG4) OR ISNULL(inQtyG4) THEN
		-- USER DEFINED ERROR (NULL VALUE IS NOT ACCEPTED).
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='Null value is not accepted.';
    ELSEIF SIGN(inQtyG4) < 0 THEN
		-- USER DEFINED ERROR (QTY CANNOT BE LESS THAN ZERO).
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='Quantity cannot be less than zero.';
    ELSE
    -- REPLENISH THE QUANTITY IN THE PARTSG4 TABLE. ADD THE NEW QUANTITY TO THE EXISTING QUANTITY.
    UPDATE PartsG4 SET qtyG4 = qtyG4 + inQtyG4 WHERE partNoG4=inPartNoG4;
	-- RECALCULATE AND UPDATE THE REORDER FLAG.
	SELECT qtyG4 INTO CURR_QTY FROM PartsG4 WHERE partNoG4 = inPartNoG4;
	SELECT minQtyG4 INTO MIN_QTY FROM PartsG4 WHERE partNoG4 = inPartNoG4;
   	IF (CURR_QTY < MIN_QTY) THEN 
		-- MARK THE PART TO BE REORDERED SINCE THE CURRENT QUANTITY IS BELOW THE MANDATORY THRESHOLD.
		UPDATE PartsG4 SET reorderG4 = 1 WHERE partNoG4 = inPartNoG4;
	ELSE
		-- MARK THE PART NOT TO BE REORDERED.
		UPDATE PartsG4 SET reorderG4 = 0 WHERE partNoG4 = inPartNoG4;
	END IF;	
	-- RETURN THE UPDATED INFORMATION BACK TO THE REQUESTOR.
	SELECT * FROM PartsG4 WHERE partNoG4=inPartNoG4;
    END IF;
    -- COMMIT THE ENTIRE CHANGE.
    COMMIT;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE PROC_CLIENT_PAYMENT_G4(IN inPoNoG4 INT(11), IN inClientCompIdG4 INT(11), IN inAmountPaidG4 DECIMAL(19,4))
BEGIN
	DECLARE COUNT_LINES INT;
	DECLARE SUM_LINEPRICE DECIMAL(19,4);
	DECLARE SUM_ALREADY_PAID DECIMAL(19,4);
	-- DEFINE AN ERROR HANDLING. FIRST ROLLBACK THEN RETHROW THE ERROR TO THE REQUESTOR APPLICATION.
    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING, NOT FOUND
    BEGIN
		ROLLBACK;
        RESIGNAL;
	END;	
	START TRANSACTION;
	-- RETRIEVE THE TOTAL PRICE.
	SELECT COUNT(*) INTO COUNT_LINES 
		FROM POsG4 INNER JOIN POLinesG4 USING(poNoG4) WHERE POsG4.poNoG4 = inPoNoG4 AND POsG4.clientCompIdG4 = inClientCompIdG4;
	SELECT SUM(linePriceG4) INTO SUM_LINEPRICE 
		FROM POsG4 INNER JOIN POLinesG4 USING(poNoG4) WHERE POsG4.poNoG4 = inPoNoG4 AND POsG4.clientCompIdG4 = inClientCompIdG4;
	IF (COUNT_LINES <= 0) THEN
		-- USER DEFINED ERROR (NO SUCH PO EXISTS FOR THE CLIENT).
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT='No product order exists for the given PO number and client Id.';
	ELSEIF (SUM_LINEPRICE <> inAmountPaidG4) THEN -- FOR NOW, WE ONLY TAKE ONE TIME PAYMENT FOR THE TOTAL PRICE FOR ONE PO.
		-- USER DEFINED ERROR (PAID AMOUNT DOES NOT MATCH THE TOTAL PRICE OF PO).
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT='The payment amount is not accurate for the cost of the product order.';
	ELSE
		-- CHECK IF THE PO HAS BEEN ALREADY PAID (ONLY POSITIVE AMOUNT PAID ARE TAKEN INTO CONSIDERATION).
		SELECT SUM(amountPaidG4) INTO SUM_ALREADY_PAID FROM PaymentG4 WHERE (poNoG4=inPoNoG4) AND (amountPaidG4 > 0);
		IF SUM_ALREADY_PAID >= SUM_LINEPRICE THEN
			-- USER DEFINED ERROR ().
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT='The product order has been already paid.';
		END IF;
		-- TAKE THE PAYMENT.
		-- (1) RECORD THE PAYMENT IN THE PaymentG4 TABLE.
        INSERT INTO PaymentG4 (poNoG4, amountPaidG4) VALUES (inPoNoG4, inAmountPaidG4);
        
		-- (2) CHANGE THE PO STATUS TO 2 (= PAID).
        UPDATE POsG4 SET statusG4 = 2 WHERE POsG4.poNoG4 = inPoNoG4;
        
		-- (3) DEDUCT THE PAID AMOUNT FROM moneyOwedG4 IN THE ClientG4 TABLE.
		UPDATE ClientG4 SET moneyOwedG4 = (moneyOwedG4 - inAmountPaidG4) WHERE clientCompIdG4=inClientCompIdG4;
		
		-- (4) SEND A SUCCESS MESSAGE.
        SELECT 'SUCCESSFULLY PROCESSED.';
        
	END IF;
	COMMIT;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE `PROC_CREATE_PO_G4`(IN inClientCompIdG4 INT(11), IN inPartNoG4 INT(11), IN inQtyG4 INT(11))
BEGIN
    DECLARE PRICE DECIMAL(19,4);
    DECLARE PONO INT;
    -- DEFINE AN ERROR HANDLING. FIRST ROLLBACK THEN RETHROW THE ERROR TO THE REQUESTOR APPLICATION.
    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING, NOT FOUND
    BEGIN
		ROLLBACK;
        RESIGNAL;
	END;
    -- TRANSACTION
	START TRANSACTION;
    IF ISNULL(inClientCompIdG4) OR ISNULL(inPartNoG4) OR ISNULL(inQtyG4) THEN
		-- USER DEFINED ERROR (NULL VALUE IS NOT ACCEPTED).
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='Null value is not accepted.';
    ELSE
        -- INSERT THE PO INTO THE POG4 TABLE.
        INSERT INTO POsG4 (clientCompIdG4) VALUES (inClientCompIdG4);
        -- CALCULATE THE LINE PRICE FOR THE PART QUANTITY
        SELECT currentPriceG4 INTO PRICE FROM PartsG4 WHERE partNoG4=inPartNoG4;
        -- SELECT THE PO NUMBER TO INSERT THE POLINE INTO THE POLINEG4 TABLE.
        SELECT poNoG4 INTO PONO FROM POsG4 ORDER BY poNoG4 DESC LIMIT 1;
        INSERT INTO POLinesG4 (poNoG4, partNoG4, linePriceG4, qtyG4) VALUES (PONO, inPartNoG4, PRICE * inQtyG4, inQtyG4);
        -- RETURN THE PURCHASE ORDER INFORMATION BACK TO THE REQUESTOR.
	    SELECT * FROM POsG4 WHERE poNoG4=PONO;
    END IF;
    -- COMMIT THE ENTIRE CHANGE.
    COMMIT;
END //
DELIMITER ;

DELIMITER $$
CREATE TRIGGER TRG_PO_HISTORY_AFTER_INSERT_G4
AFTER INSERT ON POsG4
FOR EACH ROW
BEGIN
   	INSERT INTO `HistoryG4`(`poNoG4`,`statusNoG4`,`dateG4`) VALUES (NEW.poNoG4,NEW.statusG4 ,default);
END; $$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER TRG_PO_HISTORY_AFTER_UPDATE_G4
AFTER UPDATE ON POsG4
FOR EACH ROW
BEGIN
   		INSERT INTO `HistoryG4`(`poNoG4`,`statusNoG4`,`dateG4`) VALUES (NEW.poNoG4,NEW.statusG4 ,default);
END; $$
DELIMITER ;

DELIMITER //
CREATE PROCEDURE `PROC_CHECK_QTY_G4`(IN inPONo INT(11), IN inReq VARCHAR(255))

BEGIN
	-- DECLARE THE VARIABLES FOR THE QUANTITY CALCULATION.
	DECLARE CURR_QTY INT;
	DECLARE MIN_QTY INT;
    DECLARE PARTNO INT;
    DECLARE ORDER_QTY INT;
    DECLARE POLINESNO INT;
    DECLARE done INT DEFAULT 0;
    DECLARE MY_CURSOR CURSOR FOR SELECT lineNoG4 FROM POLinesG4 WHERE poNoG4 = inPONo;
-- DEFINE AN ERROR HANDLING. FIRST ROLLBACK THEN RETHROW THE ERROR TO THE REQUESTER APPLICATION.
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    -- TRANSACTION
    START TRANSACTION;
    SET @COMMITPROMPT = 0;
	-- CURSOR CHECK QTY.
    OPEN MY_CURSOR;
    checker: LOOP
    	FETCH NEXT FROM MY_CURSOR INTO POLINESNO;
        IF done = 1 THEN
        	LEAVE checker;
        END IF;
    	-- Do something with poLineNo here
        SELECT qtyG4 INTO ORDER_QTY FROM POLinesG4 WHERE lineNoG4 = POLINESNO;
        SELECT partNoG4 INTO PARTNO FROM POLinesG4 WHERE lineNoG4 = POLINESNO;
        SELECT qtyG4 INTO CURR_QTY FROM PartsG4 WHERE partNoG4 = PARTNO;
        SELECT minQtyG4 INTO MIN_QTY FROM PartsG4 WHERE partNoG4 = PARTNO;
        IF (CURR_QTY >= ORDER_QTY) THEN
            -- update new qty.
            UPDATE PartsG4 SET qtyG4 = CURR_QTY - ORDER_QTY WHERE partNoG4 = PARTNO;
			IF ((CURR_QTY - ORDER_QTY) < MIN_QTY) THEN
				UPDATE PartsG4 SET reorderG4 = 1 WHERE partNoG4 = PARTNO;
			END IF;
        ELSE
        	SET @COMMITPROMPT = 1;
            ROLLBACK;
        END IF;
    END LOOP checker;
    CLOSE MY_CURSOR;

-- decide to rollback or commit
    IF(STRCMP(inReq, 'ROLLBACK') = 0) THEN
        ROLLBACK;
        SET @COMMITPROMPT = 2;
        SELECT @COMMITPROMPT;
    ELSEIF(STRCMP(inReq, 'COMMIT') = 0) THEN
        COMMIT;
        UPDATE POsG4 SET statusG4 = 6 WHERE poNoG4 = inPONo;
        SET @COMMITPROMPT = 2;
        SELECT @COMMITPROMPT;
    ELSEIF(STRCMP(inReq, 'CHECK') != 0) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='Null value is not accepted.';
    ELSE
    	ROLLBACK;
        SELECT @COMMITPROMPT;
    END IF;

END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE `PROC_NEW_PO_G4`(IN inClientCompIdG4 INT(11))
BEGIN
	-- INSERT A NEW PO INTO THE POG4 TABLE.
	INSERT INTO POsG4 (clientCompIdG4) VALUES (inClientCompIdG4);
	-- RETURN THE NEW PO ID OF THE NEWLY CREATED POsG4 RECORD ABOVE.
    SELECT LAST_INSERT_ID() AS NEW_ID;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE `PROC_NEW_POLINE_G4`(IN inPoNoG4 INT(11), IN inPartNoG4 INT(11), IN inQtyG4 INT(11))
BEGIN
    DECLARE PRICE DECIMAL(19,4);
	-- CALCULATE THE LINE PRICE FOR THE PART QUANTITY
	SELECT currentPriceG4 INTO PRICE FROM PartsG4 WHERE partNoG4=inPartNoG4;
	-- CREATE A NEW PO LINE USING THE PROVIDED INFO.
	INSERT INTO POLinesG4 (poNoG4, partNoG4, linePriceG4, qtyG4) VALUES (inPoNoG4, inPartNoG4, (PRICE * inQtyG4), inQtyG4);
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE `PROC_PART_PRICE_QTY_UPDATE_G4`(IN inPartNoG4 INT(11), IN inCurrentPriceG4 DECIMAL(19,4), IN inQtyG4 INT(11))
BEGIN
	-- DECLARE THE VARIABLES FOR THE QUANTITY CALCULATION.
	DECLARE CURR_QTY INT;	
	DECLARE MIN_QTY INT;
	-- DEFINE AN ERROR HANDLING. FIRST ROLLBACK THEN RETHROW THE ERROR TO THE REQUESTOR APPLICATION.
    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING, NOT FOUND
    BEGIN
		ROLLBACK;
        RESIGNAL;
	END;
    -- TRANSACTION
	START TRANSACTION;
    IF ISNULL(inPartNoG4) OR ISNULL(inCurrentPriceG4) OR ISNULL(inQtyG4) THEN
		-- USER DEFINED ERROR (NULL VALUE IS NOT ACCEPTED).
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='Null value is not accepted.';
    ELSEIF (SIGN(inPartNoG4) < 0 OR SIGN(inQtyG4) < 0) THEN
		-- USER DEFINED ERROR (PART NUM OR QTY CANNOT BE LESS THAN ZERO).
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT='PartNo and QTY cannot be less than zero.';
    ELSE
    -- (1) UPDATE THE PRICE AND QUANTITY INFORMATION OF THE PART IN THE PARTSG4 TABLE.
    UPDATE PartsG4 SET currentPriceG4=inCurrentPriceG4, qtyG4=inQtyG4 WHERE partNoG4=inPartNoG4;
	-- (2) RECALCULATE AND UPDATE THE REORDER FLAG.
	SELECT qtyG4 INTO CURR_QTY FROM PartsG4 WHERE partNoG4 = inPartNoG4;
	SELECT minQtyG4 INTO MIN_QTY FROM PartsG4 WHERE partNoG4 = inPartNoG4;
   	IF (CURR_QTY < MIN_QTY) THEN
		-- MARK THE PART TO BE RE-ORDERED SINCE THE CURRENT QUANTITY IS BELOW THE MANDATORY THRESHOLD.
		UPDATE PartsG4 SET reorderG4 = 1 WHERE partNoG4 = inPartNoG4;
	ELSE
		-- MARK THE PART NOT TO BE REORDERED.
		UPDATE PartsG4 SET reorderG4 = 0 WHERE partNoG4 = inPartNoG4;
	END IF;
	-- RETURN THE UPDATED INFORMATION BACK TO THE REQUESTOR.
	SELECT * FROM PartsG4 WHERE partNoG4=inPartNoG4;
    END IF;
    -- COMMIT THE ENTIRE CHANGE.
    COMMIT;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE PROC_PART_REORDER_G4(IN inPartNoG4 INT(11))
BEGIN
	DECLARE CURR_QTY INT;
	DECLARE MIN_QTY INT;
	SELECT qtyG4 INTO CURR_QTY FROM PartsG4 WHERE partNoG4 = inPartNoG4;
	SELECT minQtyG4 INTO MIN_QTY FROM PartsG4 WHERE partNoG4 = inPartNoG4;
   	IF (CURR_QTY < MIN_QTY) THEN 
		-- MARK THE PART TO BE REORDERED SINCE THE CURRENT QUANTY IS BELOW THE MANDATORY THRESHOLD.
		UPDATE PartsG4 SET reorderG4 = 1 WHERE partNoG4 = inPartNoG4;
	ELSE
		-- MARK THE PART NOT TO BE REORDERED.
		UPDATE PartsG4 SET reorderG4 = 0 WHERE partNoG4 = inPartNoG4;
	END IF;
END //
DELIMITER ;

DELIMITER //
CREATE TRIGGER TRG_AFTER_POLINE_INSERT_G4
AFTER
INSERT ON POLinesG4
FOR EACH ROW
BEGIN
	-- WHENEVER AFTER A NEW RECORD IN POLinesG4 IS INSERTED, UPDATE THE RE-ORDER FLAG (TRUE/FALSE) IN THE PartsG4 TABLE 
    	-- BY INVOKING A DEDICATED TRIGGER COMPARING THE CURRENT VALUES OF THE qtyG4 AND THE minQtyG4 AND UPDATE THE REORDER FLAG.
	CALL PROC_PART_REORDER_G4(NEW.partNoG4);
END  //
DELIMITER ;

DELIMITER //
CREATE TRIGGER TRG_AFTER_POLINE_UPDATE_G4
AFTER
UPDATE ON POLinesG4
FOR EACH ROW
BEGIN
	-- WHENEVER AFTER THE POLinesG4 TABLE IS UPDATED, UPDATE THE RE-ORDER FLAG (TRUE/FALSE) IN THE PartsG4 TABLE 
    	-- BY INVOKING A DEDICATED TRIGGER COMPARING THE CURRENT VALUES OF THE qtyG4 AND THE minQtyG4 AND UPDATE THE REORDER FLAG.
	CALL PROC_PART_REORDER_G4(NEW.partNoG4);
END  //
DELIMITER ;

DELIMITER $$

-- Trigger when a status is changed from a paid state (2-4) to 5 (Cancelled)
CREATE TRIGGER `POSG4_AFTER_UPDATE_STATUS_REFUND` AFTER UPDATE ON `POsG4` FOR EACH ROW BEGIN
	DECLARE qty INTEGER;
    DECLARE partNo INTEGER;
	DECLARE finished INTEGER DEFAULT 0;

	DECLARE cw CURSOR FOR SELECT partNoG4, qtyG4 from POsG4 NATURAL JOIN POLinesG4 WHERE poNoG4=old.poNoG4;
    	-- declare NOT FOUND handler
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finished = 1;

	IF new.statusG4 = 5 AND old.statusG4 != 1 THEN -- dont trigger a refund on an unpaid order
    
    SELECT SUM(linePriceG4) FROM POLinesG4 WHERE poNoG4=old.poNoG4 INTO @total;
    
    -- Step 1: Refund money
    UPDATE ClientG4 SET moneyOwedG4 = (moneyOwedG4 - @total) WHERE clientCompIdG4=old.clientCompIdG4;
	
    -- Step 2: Restock Items
    OPEN cw;
		getPart: LOOP
			FETCH cw INTO partNo, qty;
			IF finished = 1 THEN 
				LEAVE getPart;
			END IF;
			-- run repeated query
            UPDATE PartsG4 SET qtyG4=(qtyG4+qty) WHERE partNoG4=partNo; 
		END LOOP getPart;
		CLOSE cw;
    
    END IF;

END$$

DELIMITER ;

DELIMITER $$

-- Trigger when a status is changed to filled
CREATE TRIGGER `POSG4_AFTER_UPDATE_STATUS_FILLED` AFTER UPDATE ON `POsG4` FOR EACH ROW BEGIN
    DECLARE qty INTEGER;
    DECLARE partNo INTEGER;
	DECLARE finished INTEGER DEFAULT 0;

	DECLARE cw CURSOR FOR SELECT partNoG4, qtyG4 from POsG4 NATURAL JOIN POLinesG4 WHERE poNoG4=old.poNoG4;
    -- declare NOT FOUND handler
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET finished = 1;

	IF new.statusG4 = 6 THEN

    SELECT SUM(linePriceG4) FROM POLinesG4 WHERE poNoG4=old.poNoG4 INTO @total;

    -- Step 1: update money
    UPDATE ClientG4 SET moneyOwedG4 = (moneyOwedG4 + @total) WHERE clientCompIdG4=old.clientCompIdG4;

END IF;

END$$

DELIMITER ;